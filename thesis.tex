% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[english,shortabstract,mgr]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Tłumaczenie współczesnego języka programowania\fmlinebreak do Maszyny Minsky'ego.}
\englishtitle   {Modern programming language translation to theoretical model of Minsky Machine (Counter Machine).}
\polishabstract {TODO: polishabstract}
\englishabstract{
Counter Machine (a machine with finite state set, two counters and input/output tape) is~able to express any
computations done by~modern programming languages. This is~well known theorem, just like computations
performed using Turing Machine and~means that anything written in modern programming language is possible
to~translate into theoretical model of Minsky Machine (as well as into Turing Machine).

My goal is to build automatic translation from modern programming language (C++) to Minsky Machine.
}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Jadwiga Pokorska}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Jakub Michaliszyn}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum {247906}                     % Numer indeksu
\advisorgen    {dr Jakuba Michaliszyn} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Introduction}

\ldots

\chapter {Specifications of languages}

\section {Brainfuck}
TODO.

\section {Turing Machine}

\subsection {Instructions}

Turing Machine consists of finite number of states, changes between them
and~potentially infinite tape, on~which it is able to~write and~read symbols.
It has no code sequence, program is a~set of state changes and~definition
of~initial state. There is special final state \texttt{END} that does not need
to~be defined to~be used.

There is predefined set of symbols used on the tape which is whole ASCII character set
extended with the same amount of additional (non-ASCII) symbols. Regular
ASCII characters have 7 bits (numbers 0-127), so tape symbols have 8 bits
allowing to hold regular ASCII and special characters (numbers 128-255).

There are few special definitions (so far using regular ASCII,
but it will be changed to use special characters instead):
\begin{itemize}
  \item \texttt{BLANK} which represents empty field on the tape
  \item \texttt{*} (ALL) defines all characters (both ASCII and special)
  \item \texttt{\#} (NOTHING) means no character which is used to say
                   that we do not want to write anything on tape during
                   this state change
  \item \texttt{\&} (NON-ZERO) defines all characters except 0
  \item \texttt{0} (ZERO) represents zero that is used for condotional jumps
                   (jump zero)
  \item \texttt{>} (NEXT-CHAR) allows to write on the tape next character
                   (increased by one), i.e. writes \texttt{g} if on the tape
                   was \texttt{f}
  \item \texttt{<} (PREV-CHAR) similarly as above but writes previous caracted,
                   i.e. writes \texttt{e} when seen \texttt{f}
\end{itemize}

Defining initial state:
\begin{verbatim}
START: <state name>
\end{verbatim}

Each state change looks as follows:
\begin{verbatim}
<state name> <symbol(s)> -> <target state> <head move> <symbol to write>
\end{verbatim}

\texttt{symbol(s)} is ASCII character including special definitions (currently
all special definitions use regular ASCII, so that it is easy to see
in standard text file), in future it will allow to get non-ASCII special
characters as well.

\texttt{head move} is one of: \texttt{L}, \texttt{R} or \texttt{-} which
steer the head to go left, right or stay in place, respectively.

\texttt{symbol to write} is any (currently ASCII) symbol. Currently there
is no mechanism to prevent writing any symbol from special definitions,
but~it will cause undefined behaviour of~the machine. The only symbol
from special definitions that is allowed to appear as \texttt{symbol to write}
is \texttt{\#} (NOTHING) meaning that symbol on the tape should not change.

\subsection {Extensions of theoretical model}

Standard input/output handling is done by allowing to read or write single
ASCII character from/to stdin/stdout. It is possible to~add additional
reading or~writing before moving head. It is done by modifying change
symbol \texttt{->} in state change definition.
\begin{itemize}
  \item Reading is done with \texttt{->*}, i.e. \texttt{state1 A ->* state2 R NOTHING}
        which means when seen symbol \texttt{A} in state \texttt{state1} we read
        from stdin one character, overwrite \texttt{A} to read value and move
        head one field right.
  \item Writing is done similarly with \texttt{->\^},
        i.e. \texttt{state1 A ->\^ state2 R NOTHING} which will print symbol
        \texttt{A} on stdout and move head right.
\end{itemize}

\subsection{Example}

Program that reads letter from stdin, writes this letter and next one into
stdout and second written letter was \texttt{B} or \texttt{b} then prints
\texttt{.} at the end as well, otherwise finishes.

\begin{verbatim}
START: s1
s1 ALL ->* s2 - NOTHING
s2 ALL ->^ s3 - NEXT_CHAR
s3 ALL -> s4 - NOTHING
s4 b ->^ s5 R NOTHING
s4 B ->^ s5 R NOTHING
s5 ALL -> s6 - .
s6 ALL ->^ s7 - NOTHING
s7 ALL -> END - NOTHING
\end{verbatim}

Note: If there is no state change defined for given configuration
(nothing matches) then it is assumed that machine gets to \texttt{END} state.
Because of this in the above example last instruction is not necessary.

\section {2 Stack Pushdown Automaton}

2 Stack PushDown Automaton consists of two stacks, input tape and~definition
of~states and transitions between them. Each transition looks as follows:
\begin{verbatim}
<state name> <left pattern> <right pattern> ->
    <target state> <left stack items> <right stack items>
\end{verbatim}

Explanation:
\begin{itemize}
  \item \texttt{left pattern} is symbol or pattern that should be matched
      for symbol at the top of left stack
  \item \texttt{right pattern} is the same as above, but for right stack
  \item \texttt{left stack items} is list of items that should be pushed to left stack before moving
      to \texttt{target state}. It might be single letter \texttt{"a"}, sequence of letters
      \texttt{"abc"} or~sequence of~letters and~references, i.e. \texttt{("a" + ORIG\_LEFT + "b")}
      where \texttt{ORIG\_LEFT} means the letter we read from left stack (the one matched
      in \texttt{left pattern}). Note: If \texttt{+} is used it is required to put whole sequence in parenthesis
  \item \texttt{right stack items} is the same as above, but for items to be pushed into right stack
\end{itemize}

Special references and definitions in transitions:
\begin{itemize}
  \item \texttt{ORIG\_LEFT} is the letter taken from left stack
  \item \texttt{ORIG\_RIGHT} is the letter taken from right stack
  \item \texttt{INPUT\_CHAR} is the letter taken from input tape
      (only in input transition type - see section below)
  \item \texttt{NOTHING} may be used as \texttt{left stack items} or \texttt{right stack items}
      and means that nothing is pushed into left/right stack
  \item \texttt{END} is special state name where transition is made if no other transition is specified
  \item \texttt{\$} is symbol of empty stack
\end{itemize}

\subsection {Extensions of theoretical model}

Input/Ouput handling is done similarly to Turing Machine - We change \texttt{->} in transition
to \texttt{->*} or \texttt{->\^}.

When defining input transition it is allowed to use \texttt{INPUT\_CHAR} in any items
to be pushed into left/right stack. Here is example that takes character from input
tape and pushes it into left stack (and ignores symbols taken from both stacks).
\begin{verbatim}
state1 ALL ALL ->* state2 INPUT_CHAR NOTHING
\end{verbatim}

When defining output transition we \textbf{must} specify what character is printed
with adding \texttt{Output: <letter>} at the very back of transition definition.
Example that prints letter taken from left stack (and ignores what was taken from right stack):
\begin{verbatim}
state1 ALL ALL ->^ state2 NOTHING NOTHING Output: ORIG_LEFT
\end{verbatim}
Example that prints letter "a" (and ignores what was taken from stacks):
\begin{verbatim}
state1 ALL ALL ->^ state2 NOTHING NOTHING Output: "a"
\end{verbatim}

\textbf{Important note:} Order of defining transition matters. If patterns do not match
distinct set of letters then the transition that appeared first is applied.

\subsection{Example}

Example (equivalent to example from Turing Machine):
\begin{verbatim}
START: init_state
init_state $ $ -> s1 BLANK NOTHING
s1 ALL ALL ->* s2 INPUT_CHAR ORIG_RIGHT
s2 ALL ALL ->^ s3 ORIG_LEFT ORIG_RIGHT Output: ORIG_LEFT
s3 b $ -> s4 (ORIG_LEFT + BLANK) $
s3 b ALL -> s4 (ORIG_LEFT + ORIG_RIGHT) NOTHING
s3 B $ -> s4 (ORIG_LEFT + BLANK) $
s3 B ALL -> s4 (ORIG_LEFT + ORIG_RIGHT) NOTHING
s4 ALL ALL -> s5 "." ORIG_RIGHT
s5 ALL ALL ->^ s6 ORIG_LEFT ORIG_RIGHT Output: ORIG_LEFT
s6 ALL ALL -> END ORIG_LEFT ORIG_RIGHT
\end{verbatim}

\section {Counter Machine (4 counters)}

Counter Machine consists of $4$ counters each holding non-negative integer,
finite number of states and~transitions between them. Each transition
looks as follows:

\begin{verbatim}
<state name> (<pattern> <pattern> <pattern> pattern>) ->
    <target state> (<number> <number> <number> <number>)
\end{verbatim}

Where:
\begin{itemize}
  \item \texttt{<state name>} is the state in which counter machine needs to be
      within for this transition to be applied,
  \item \texttt{<pattern>} is one of values \texttt{0}, texttt{1} or texttt{\_}
      meaning empty counter, non-empty counter and any counter state and defines
      what is expected state of given counter - the transition may be applied
      only when all counter states are matched (Notice that symbol \texttt{\_}
      is matched with any state of the counter),
  \item \texttt{target state} is the state in which machine will be after
      applying the transition,
  \item \texttt{<number>} is integer from range \texttt{[-1, MAX\_INT]} specifying
      what should be added to given counter - it is allowed to decrease counter
      by $1$ only, but it is possible to increase it by any number that can be stored
      in regular integer type.
\end{itemize}

\textbf{Note:} If there are many transitions that may be applied in given state
matching all counters \textbf{the first one} is applied. It means that order
of defining transitions matters.

It is required to give initial state of the machine with following statement:
\begin{verbatim}
START: <state name>
\end{verbatim}

\subsection {Extensions of theoretical model}

Input/Output operations fit in the schema of using counters - input and output
are additional counters which transitions may use in similar way as counters are used.

Input transition is defined as follows:
\begin{verbatim}
<state name> (<counters>) <input pattern> ->*
    <target state> (<numbers>) <input operation>
\end{verbatim}

Where:
\begin{itemize}
  \item \texttt{<input pattern>} is one of \texttt{0}, \texttt{1} or \texttt{\_}
      (same as counter pattern) and specifies what should be the state
      of input counter for this transition to be applied,
  \item \texttt{<input operation>} specifies what action should be performed
      on input counter and is one of \texttt{LOAD}, \texttt{-1} or \texttt{NOOP}
      meaning respectively loading character from stdin into the input counter,
      decrease input counter by `1` and leaving input counter untouched.
\end{itemize}

This transition reads from stdin into input counter:
\begin{verbatim}
state1 (_ _ _ _) _ ->* state2 (0 0 0 0) LOAD
\end{verbatim}

These transitions read value from input counter and store it in first counter:
\begin{verbatim}
state1 (_ _ _ _) 1 ->* state1 (1 0 0 0) -1
state1 (_ _ _ _) 0 ->* state2 (0 0 0 0) NOOP
\end{verbatim}

Note: It is assumed that transition may just decrease the input counter
and is not allowed to increase its value directly.

Output transition is defined as follows:
\begin{verbatim}
<state name> (<counters>) ->^ <target state> (<numbers>) Output: <output operation>
\end{verbatim}

Where:
\begin{itemize}
  \item \texttt{<output operation>} specifies what should be performed
      on output counter and may be one of \texttt{FLUSH} or non-negative number,
      meaning respectively pushing counter to stdout and modifying
      value stored in the counter by given number.
\end{itemize}

These transitions print character stored in first counter:
\begin{verbatim}
state1 (1 _ _ _) ->^ state1 (-1 0 0 0) Output: 1
state1 (0 _ _ _) ->^ state2 (0 0 0 0) Output: FLUSH
\end{verbatim}

Note: It is assumed that transition may just increase the output counter
and is not allowed to decrease its value directly.


\subsection{Example}

Code that reads character from stdin doubles its ASCII value and prints the result.
\begin{verbatim}
START: s1
s1 (_ _ _ _) _ ->* s2 (0 0 0 0) LOAD
s2 (_ _ _ _) 1 ->* s2 (1 0 0 0) -1
s2 (_ _ _ _) 0 ->* s3 (0 0 0 0) NOOP
s3 (1 _ _ _) -> s3 (-1 2 0 0)
s3 (0 _ _ _) -> s4 (0 0 0 0)
s4 (_ 1 _ _) ->^ s4 (0 -1 0 0) Output: 1
s4 (_ 0 _ _) ->^ END (0 0 0 0) Output: FLUSH
\end{verbatim}

\section {Counter Machine (2 counters)}

Counter Machine with 2 counters has the same definition like
Counter Machine with 4 counters, but it is allowed to use only
2 counters, so transitions become of the form:

\begin{verbatim}
<state name> (<pattern> <pattern>) -> <target state> (<number> <number>)
\end{verbatim}

Input/Ouput is handled the same way it is handled in Counter Machine with 4 counters.

\section {Minsky Machine - OLD}

\subsection {Instructions}
Minsky Machine (currently) consists of finite number of counters
each holding one non-negative integer and sequence of instructions.
Each instruction might be prefixed by a label which will be used for
code execution and allow to jump into desired code parts. (The idea is similar
to RAM machine.)

Each of the instructions is one of the following ones:
\begin{itemize}
  \item \texttt{INC <number>} increases given counter
  \item \texttt{DEC <number>} decreases given counter
  \item \texttt{PRINT <number>} prints state of given counter to standard output
  \item \texttt{READ <number>} reads number from standard input into given counter
  \item \texttt{JZ <number> <label>} if value of given counter is 0 then execution
        will continue from place in code with given label
\end{itemize}

\subsection {Example}
Program that reads number $n$ from stdin and writes $2 \cdot n$ to stdout.

\begin{verbatim}
      READ 1
loop: JZ 1 end
      DEC 1
      INC 2
      INC 2
      JZ 3 loop
end:  PRINT 2
\end{verbatim}

%%%%% BIBLIOGRAFIA

%\begin{thebibliography}{1}
%\bibitem{example} \ldots
%\end{thebibliography}

\end{document}
